# 포인트 패키지

## API 엔드포인트

### PATCH `/point/{id}/charge`
주어진 사용자 ID로 포인트를 충전합니다.

### PATCH `/point/{id}/use`
주어진 사용자 ID로 포인트를 사용합니다.

### GET `/point/{id}`
주어진 사용자 ID의 현재 포인트 잔액을 조회합니다.

### GET `/point/{id}/histories`
주어진 사용자 ID의 포인트 사용 내역을 조회합니다.

## 요구사항

- 잔고가 부족할 경우, 포인트 사용은 실패해야 합니다.
- 동시에 여러 건의 포인트 충전, 사용 요청이 들어올 경우 순차적으로 처리되어야 합니다. (동시성 처리)

## TODO

- [ ] `PATCH /point/{id}/charge` 엔드포인트 구현
- [ ] `PATCH /point/{id}/use` 엔드포인트 구현
- [ ] `GET /point/{id}` 엔드포인트 구현
- [ ] `GET /point/{id}/histories` 엔드포인트 구현
- [ ] 잔고 부족 시 포인트 사용 실패 처리
- [ ] 동시 요청에 대한 순차 처리 구현

## 테스트 케이스

- [ ] 포인트 충전 성공 테스트 케이스
- [ ] 잔고 충분 시 포인트 사용 성공 테스트 케이스
- [ ] 잔고 부족 시 포인트 사용 실패 테스트 케이스
- [ ] 다중 충전 및 사용 후 정확한 잔액 확인 테스트 케이스
- [ ] 포인트 사용 내역이 정확히 기록되고 조회되는지 확인하는 테스트 케이스
- [ ] 동시 요청에 대한 순차 처리 확인 테스트 케이스

## 느낀점
동시성 테스트 자체는 방법을 알면 어렵지 않지만, 실제 테스트 과정은 곤욕스러웠다. 예를 들어서 thread 관련 method를 사용하고 null이 반환되는 등의 문제가 있다. Mockito는 기본적으로 단일 스레드 환경에서의 사용을 위해 설계되어 있어, 멀티스레드 환경에서는 예기치 않은 동작이 발생할 수 있다. mock 객체를 @BeforeEach나 @Before에서 메모리 할당을 하고 시작하여 스레드 테스트를 할 수는 있지만, 그렇게 하면 테스트의 의미가 무색해진다. 차라리 별도의 단위 테스트를 만들어 mock 객체를 사용하는 것이 낫다.
